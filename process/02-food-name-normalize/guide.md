# 食品名構造化スキーマ設計解説

## 概要

日本食品標準成分表のD列（食品名）を構造化するためのZodスキーマです。

### 元データの特徴

```
こむぎ　［小麦粉］　薄力粉　1等
こむぎ　［小麦粉］　薄力粉　2等
つるあずき　全粒　乾
つるあずき　全粒　ゆで
＜魚類＞　（さけ・ます類）　たいせいようさけ　養殖　皮つき　生
```

- 全角スペース「　」で区切られた複数要素
- 括弧による階層: `＜大分類＞` → `［中分類］` → `（小分類/類）`
- 構造ルールが明示されておらず、前後の行から推測が必要

---

## スキーマ設計のポイント

### 1. 項目を最小限に抑制

2,538件の食品を分析した結果、以下の9項目に集約：

| フィールド | 説明 | 例 |
|-----------|------|-----|
| `original` | 元の食品名 | `こむぎ　［小麦粉］　薄力粉　1等` |
| `categoryPath` | カテゴリ階層 | `["小麦粉"]` |
| `baseName` | 基本食品名 | `こむぎ` |
| `variety` | 品種・種類 | `薄力粉` |
| `part` | 部位 | `もも`, `葉` |
| `formModifiers` | 形態修飾子 | `["皮つき", "脂身つき"]` |
| `productionMethod` | 生産方法 | `養殖` |
| `origin` | 産地 | `国産` |
| `state` | 最終状態 | `生`, `ゆで`, `乾` |
| `grade` | 等級 | `1等` |
| `notes` | 補足情報 | `["添付調味料等を含むもの"]` |

### 2. 列挙型の厳選

**列挙型として定義したもの（値が限定的）:**
- `FoodStateEnum`: 調理・保存状態（30種程度）
- `FormModifierEnum`: 形態修飾子（10種程度）
- `ProductionMethodEnum`: 生産方法（4種）

**自由テキストとしたもの（値が多様）:**
- `part`: 部位（植物・動物で50種以上）
- `origin`: 産地（国名が多様）
- `variety`: 品種（食品ごとに異なる）

### 3. 比較可能性の確保

同じ食品の異なる状態を比較できるよう設計：

```typescript
// 「つるあずき 全粒 乾」と「つるあずき 全粒 ゆで」
// → getGroupKey()が同じ値を返す → 比較可能
```

---

## 列挙型の定義

### FoodStateEnum（最終状態）

```typescript
export const FoodStateEnum = z.enum([
  // 未加工
  "生",
  
  // 加熱調理（湿式）
  "ゆで", "水煮", "蒸し",
  
  // 加熱調理（油式）
  "油いため", "フライ", "天ぷら", "から揚げ", "素揚げ", "ソテー",
  
  // 加熱調理（乾式）
  "焼き", "いり",
  
  // 電子レンジ
  "電子レンジ調理",
  
  // 乾燥・保存
  "乾", "乾燥", "冷凍",
  
  // 漬物系
  "塩漬", "ぬかみそ漬", "甘酢漬", "しょうゆ漬", "みそ漬",
  
  // 缶詰・加工
  "缶詰", "水煮缶詰",
  
  // 干物
  "素干し", "煮干し", "丸干し",
  
  // 燻製
  "くん製",
  
  // 抽出
  "浸出液",
  
  // 前処理
  "塩抜き", "水戻し",
]);
```

### FormModifierEnum（形態修飾子）

```typescript
export const FormModifierEnum = z.enum([
  // 皮
  "皮つき", "皮なし",
  
  // 脂肪
  "脂身つき", "皮下脂肪なし", "赤肉", "脂身",
  
  // 粒
  "全粒",
  
  // 卵
  "全卵", "卵黄", "卵白",
]);
```

---

## パース結果の例

### 例1: 穀類（小麦粉）

**入力:** `こむぎ　［小麦粉］　薄力粉　1等`

```json
{
  "original": "こむぎ　［小麦粉］　薄力粉　1等",
  "categoryPath": ["小麦粉"],
  "baseName": "こむぎ",
  "variety": "薄力粉",
  "grade": "1等"
}
```

### 例2: 豆類（状態違い比較）

**入力:** `つるあずき　全粒　乾` / `つるあずき　全粒　ゆで`

```json
// 乾
{
  "original": "つるあずき　全粒　乾",
  "categoryPath": [],
  "baseName": "つるあずき",
  "formModifiers": ["全粒"],
  "state": "乾"
}

// ゆで
{
  "original": "つるあずき　全粒　ゆで",
  "categoryPath": [],
  "baseName": "つるあずき",
  "formModifiers": ["全粒"],
  "state": "ゆで"
}
```

### 例3: 魚類（複雑な例）

**入力:** `＜魚類＞　（さけ・ます類）　たいせいようさけ　養殖　皮つき　生`

```json
{
  "original": "＜魚類＞　（さけ・ます類）　たいせいようさけ　養殖　皮つき　生",
  "categoryPath": ["魚類", "さけ・ます類"],
  "baseName": "たいせいようさけ",
  "productionMethod": "養殖",
  "formModifiers": ["皮つき"],
  "state": "生"
}
```

### 例4: 畜肉類

**入力:** `＜畜肉類＞　うし　［和牛肉］　もも　脂身つき　生`

```json
{
  "original": "＜畜肉類＞　うし　［和牛肉］　もも　脂身つき　生",
  "categoryPath": ["畜肉類", "和牛肉"],
  "baseName": "うし",
  "part": "もも",
  "formModifiers": ["脂身つき"],
  "state": "生"
}
```

---

## 活用方法

### 1. 同一食品の状態比較

```typescript
// stateだけが異なる食品をグループ化
const groupedFoods = foods.reduce((acc, food) => {
  const key = getGroupKey(food);
  if (!acc[key]) acc[key] = [];
  acc[key].push(food);
  return acc;
}, {});

// 例: 「つるあずき 全粒」の「乾」と「ゆで」を比較
```

### 2. カテゴリ別フィルタリング

```typescript
// 魚類のみ抽出
const fishFoods = foods.filter(f => 
  f.categoryPath.includes("魚類")
);

// さけ・ます類のみ
const salmonFoods = foods.filter(f => 
  f.categoryPath.includes("さけ・ます類")
);
```

### 3. 調理状態での検索

```typescript
// 「生」の食品のみ
const rawFoods = foods.filter(f => f.state === "生");

// 「ゆで」で調理可能な食品
const boilableFoods = foods.filter(f => 
  f.state === "ゆで" || f.state === "生"
);
```

---

## 元データ分析結果

### 出現頻度の高い状態

| 状態 | 件数 |
|-----|------|
| 生 | 775 |
| ゆで | 194 |
| 焼き | 90 |
| 乾 | 73 |
| 水煮 | 41 |
| 油いため | 41 |

### 括弧の使用パターン

| 括弧 | 用途 | 例 |
|-----|------|-----|
| `＜＞` | 大分類 | 魚類, 畜肉類, いも類 |
| `［］` | 中分類/製品カテゴリ | 小麦粉, パン類, 和牛肉 |
| `（）` | 小分類/類 または 補足 | かんきつ類, 添付調味料等を含むもの |